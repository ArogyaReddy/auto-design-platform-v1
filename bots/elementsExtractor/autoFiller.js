// Auto-Filler Module for Element AI Extractor
// Provides intelligent form filling and element interaction capabilities

// Single execution guard
if (window.aiExtractorAutoFillerScript) {
    console.log('Element AI Extractor: Auto-filler script already loaded');
} else {
    window.aiExtractorAutoFillerScript = true;
    
    // Define the SmartAutoFiller class
    class SmartAutoFiller {
    constructor() {
        this.isTestMode = false;
        this.fillData = this.getDefaultFillData();
        this.interactionLog = [];
        this.isRunning = false;
        this.shadowDOMSupport = true;
        
        // Load custom data from storage
        this.loadCustomFillData();
        
        // Bind methods
        this.autoFillForms = this.autoFillForms.bind(this);
        this.autoInteract = this.autoInteract.bind(this);
        this.setTestMode = this.setTestMode.bind(this);
    }

    // Load custom fill data from Chrome storage
    async loadCustomFillData() {
        try {
            if (typeof chrome !== 'undefined' && chrome.storage) {
                const result = await new Promise((resolve) => {
                    chrome.storage.local.get(['autoFillerCustomData'], resolve);
                });
                
                if (result.autoFillerCustomData) {
                    // Merge custom data with defaults
                    this.fillData = { ...this.getDefaultFillData(), ...result.autoFillerCustomData };
                    this.log('Custom fill data loaded from settings', 'info');
                }
            }
        } catch (error) {
            this.log(`Error loading custom data: ${error.message}`, 'warning');
        }
    }

    // Default data for form filling
    getDefaultFillData() {
        return {
            // Personal Information
            firstName: 'John',
            lastName: 'Doe',
            fullName: 'John Doe',
            name: 'John Doe',
            
            // Contact Information
            email: 'john.doe@example.com',
            phone: '+1-555-123-4567',
            mobile: '+1-555-123-4567',
            
            // Address Information
            address: '123 Main Street',
            street: '123 Main Street',
            city: 'New York',
            state: 'NY',
            zip: '10001',
            zipcode: '10001',
            postalCode: '10001',
            country: 'United States',
            
            // Company Information
            company: 'Example Corp',
            jobTitle: 'Software Engineer',
            department: 'Engineering',
            
            // Account Information
            username: 'johndoe123',
            password: 'TestPassword123!',
            
            // Other Common Fields
            age: '30',
            birthdate: '1993-01-01',
            website: 'https://example.com',
            bio: 'This is a test biography for form filling purposes.',
            message: 'This is a test message generated by the auto-filler tool.',
            comment: 'Test comment from auto-filler.',
            description: 'Test description for auto-fill demonstration.',
            
            // Dropdowns and Selects
            gender: 'male',
            title: 'Mr',
            
            // Checkboxes (boolean values)
            newsletter: true,
            terms: true,
            privacy: true,
            marketing: false
        };
    }

    // Update fill data from user settings
    updateFillData(newData) {
        this.fillData = { ...this.fillData, ...newData };
        this.log('Fill data updated', 'info');
    }

    // Set test mode (safe mode - no actual form submissions)
    setTestMode(enabled) {
        this.isTestMode = enabled;
        this.log(`Test mode ${enabled ? 'enabled' : 'disabled'}`, 'info');
    }

    // Log interactions
    log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const entry = {
            timestamp,
            message,
            type
        };
        this.interactionLog.push(entry);
        console.log(`Auto-Filler [${type.toUpperCase()}]: ${message}`);
    }

    // Clear log
    clearLog() {
        this.interactionLog = [];
    }

    // Get log entries
    getLog() {
        return this.interactionLog;
    }

    // Detect field type based on element attributes
    detectFieldType(element) {
        const name = (element.name || '').toLowerCase();
        const id = (element.id || '').toLowerCase();
        const placeholder = (element.placeholder || '').toLowerCase();
        const ariaLabel = (element.getAttribute('aria-label') || '').toLowerCase();
        const className = (element.className || '').toLowerCase();
        const type = (element.type || '').toLowerCase();
        
        const combined = `${name} ${id} ${placeholder} ${ariaLabel} ${className}`;
        
        // Email detection
        if (type === 'email' || combined.includes('email') || combined.includes('e-mail')) {
            return 'email';
        }
        
        // Password detection
        if (type === 'password' || combined.includes('password') || combined.includes('pass')) {
            return 'password';
        }
        
        // Phone detection  
        if (type === 'tel' || combined.includes('phone') || combined.includes('tel') || 
            combined.includes('mobile') || combined.includes('cell')) {
            return 'phone';
        }
        
        // Name detection
        if (combined.includes('firstname') || combined.includes('first-name') || combined.includes('first_name')) {
            return 'firstName';
        }
        if (combined.includes('lastname') || combined.includes('last-name') || combined.includes('last_name')) {
            return 'lastName';
        }
        if (combined.includes('fullname') || combined.includes('full-name') || combined.includes('full_name') ||
            (combined.includes('name') && !combined.includes('user') && !combined.includes('company'))) {
            return 'fullName';
        }
        if (combined.includes('username') || combined.includes('user-name') || combined.includes('user_name')) {
            return 'username';
        }
        
        // Address detection
        if (combined.includes('address') || combined.includes('street')) {
            return 'address';
        }
        if (combined.includes('city')) {
            return 'city';
        }
        if (combined.includes('state') || combined.includes('province')) {
            return 'state';
        }
        if (combined.includes('zip') || combined.includes('postal')) {
            return 'zip';
        }
        if (combined.includes('country')) {
            return 'country';
        }
        
        // Company detection
        if (combined.includes('company') || combined.includes('organization')) {
            return 'company';
        }
        if (combined.includes('job') && combined.includes('title')) {
            return 'jobTitle';
        }
        
        // Other common fields
        if (combined.includes('age')) {
            return 'age';
        }
        if (combined.includes('birth') || combined.includes('dob')) {
            return 'birthdate';
        }
        if (combined.includes('website') || combined.includes('url')) {
            return 'website';
        }
        if (combined.includes('bio') || combined.includes('about')) {
            return 'bio';
        }
        if (combined.includes('message') || combined.includes('msg')) {
            return 'message';
        }
        if (combined.includes('comment')) {
            return 'comment';
        }
        if (combined.includes('description') || combined.includes('desc')) {
            return 'description';
        }
        
        // Generic text fallback
        if (type === 'text' || type === 'search' || element.tagName === 'TEXTAREA') {
            return 'fullName'; // Default text input
        }
        
        return null;
    }

    // Fill a single form element
    async fillElement(element, fieldType, value) {
        if (!element || element.disabled || element.readOnly) {
            return false;
        }

        try {
            // Focus the element first
            element.focus();
            await this.sleep(100);

            if (element.tagName === 'SELECT') {
                // Handle dropdowns
                return this.fillSelect(element, value);
            } else if (element.type === 'checkbox' || element.type === 'radio') {
                // Handle checkboxes and radio buttons
                return this.fillCheckboxRadio(element, value);
            } else if (element.tagName === 'TEXTAREA' || element.type === 'text' || 
                      element.type === 'email' || element.type === 'tel' || element.type === 'password' ||
                      element.type === 'search' || element.type === 'url') {
                // Handle text inputs
                return this.fillTextInput(element, value);
            }

            return false;
        } catch (error) {
            this.log(`Error filling element: ${error.message}`, 'error');
            return false;
        }
    }

    // Fill text input
    async fillTextInput(element, value) {
        try {
            // Clear existing value
            element.value = '';
            element.dispatchEvent(new Event('input', { bubbles: true }));
            await this.sleep(50);

            // Type the new value
            element.value = value;
            
            // Dispatch events to trigger any listeners
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            element.dispatchEvent(new Event('blur', { bubbles: true }));
            
            await this.sleep(100);
            this.log(`Filled text input with: ${value}`, 'success');
            return true;
        } catch (error) {
            this.log(`Error filling text input: ${error.message}`, 'error');
            return false;
        }
    }

    // Fill select dropdown
    async fillSelect(element, value) {
        try {
            // Try to find matching option by value or text
            const options = Array.from(element.options);
            let selectedOption = null;

            // First try exact value match
            selectedOption = options.find(opt => opt.value.toLowerCase() === value.toLowerCase());
            
            // Then try text content match
            if (!selectedOption) {
                selectedOption = options.find(opt => opt.textContent.toLowerCase().includes(value.toLowerCase()));
            }
            
            // Finally try any option that isn't empty/default
            if (!selectedOption) {
                selectedOption = options.find(opt => opt.value && opt.value !== '0' && opt.textContent.trim());
            }

            if (selectedOption) {
                element.value = selectedOption.value;
                element.selectedIndex = selectedOption.index;
                element.dispatchEvent(new Event('change', { bubbles: true }));
                await this.sleep(100);
                this.log(`Selected option: ${selectedOption.textContent}`, 'success');
                return true;
            }
            
            this.log(`No suitable option found for value: ${value}`, 'warning');
            return false;
        } catch (error) {
            this.log(`Error filling select: ${error.message}`, 'error');
            return false;
        }
    }

    // Fill checkbox or radio button
    async fillCheckboxRadio(element, value) {
        try {
            const shouldCheck = Boolean(value);
            if (element.checked !== shouldCheck) {
                element.checked = shouldCheck;
                element.dispatchEvent(new Event('change', { bubbles: true }));
                await this.sleep(100);
                this.log(`${shouldCheck ? 'Checked' : 'Unchecked'} ${element.type}: ${element.name || element.id}`, 'success');
                return true;
            }
            return false;
        } catch (error) {
            this.log(`Error filling ${element.type}: ${error.message}`, 'error');
            return false;
        }
    }

    // Get all form elements from the page (including shadow DOM)
    getAllFormElements() {
        const elements = [];
        
        // Regular DOM elements
        const regularElements = document.querySelectorAll('input, select, textarea');
        elements.push(...regularElements);
        
        // Shadow DOM elements if supported
        if (this.shadowDOMSupport) {
            try {
                const shadowElements = this.getShadowDOMElements();
                elements.push(...shadowElements);
            } catch (error) {
                this.log(`Error accessing shadow DOM: ${error.message}`, 'warning');
            }
        }
        
        return elements;
    }

    // Get form elements from shadow DOM
    getShadowDOMElements() {
        const elements = [];
        
        const getAllShadowRoots = (root) => {
            const walker = document.createTreeWalker(
                root,
                NodeFilter.SHOW_ELEMENT,
                null,
                false
            );
            
            let node;
            while (node = walker.nextNode()) {
                if (node.shadowRoot) {
                    const shadowElements = node.shadowRoot.querySelectorAll('input, select, textarea');
                    elements.push(...shadowElements);
                    // Recursively check nested shadow roots
                    getAllShadowRoots(node.shadowRoot);
                }
            }
        };
        
        getAllShadowRoots(document);
        return elements;
    }

    // Main auto-fill function
    async autoFillForms() {
        if (this.isRunning) {
            this.log('Auto-fill already in progress', 'warning');
            return;
        }

        this.isRunning = true;
        this.clearLog();
        this.log('Starting auto-fill process...', 'info');

        try {
            const elements = this.getAllFormElements();
            this.log(`Found ${elements.length} form elements`, 'info');

            let filledCount = 0;
            let skippedCount = 0;

            for (const element of elements) {
                // Skip if element is not visible or interactable
                if (!this.isElementInteractable(element)) {
                    skippedCount++;
                    continue;
                }

                const fieldType = this.detectFieldType(element);
                if (fieldType && this.fillData[fieldType]) {
                    const success = await this.fillElement(element, fieldType, this.fillData[fieldType]);
                    if (success) {
                        filledCount++;
                    } else {
                        skippedCount++;
                    }
                } else {
                    skippedCount++;
                }

                // Small delay between fills
                await this.sleep(200);
            }

            this.log(`Auto-fill completed: ${filledCount} filled, ${skippedCount} skipped`, 'success');
            
        } catch (error) {
            this.log(`Auto-fill error: ${error.message}`, 'error');
            throw error;
        } finally {
            this.isRunning = false;
        }
    }

    // Auto-interact with clickable elements
    async autoInteract() {
        if (this.isRunning) {
            this.log('Auto-interact already in progress', 'warning');
            return;
        }

        this.isRunning = true;
        this.log('Starting auto-interact process...', 'info');

        try {
            const clickableElements = this.getClickableElements();
            this.log(`Found ${clickableElements.length} clickable elements`, 'info');

            let interactCount = 0;
            let skippedCount = 0;

            for (const element of clickableElements) {
                // Skip dangerous elements in test mode
                if (this.isTestMode && this.isDangerousElement(element)) {
                    this.log(`Skipped dangerous element in test mode: ${this.getElementDescription(element)}`, 'warning');
                    skippedCount++;
                    continue;
                }

                // Skip if element is not visible or interactable
                if (!this.isElementInteractable(element)) {
                    skippedCount++;
                    continue;
                }

                try {
                    await this.clickElement(element);
                    interactCount++;
                    await this.sleep(500); // Longer delay between clicks
                } catch (error) {
                    this.log(`Failed to click element: ${error.message}`, 'error');
                    skippedCount++;
                }
            }

            this.log(`Auto-interact completed: ${interactCount} clicked, ${skippedCount} skipped`, 'success');
            
        } catch (error) {
            this.log(`Auto-interact error: ${error.message}`, 'error');
            throw error;
        } finally {
            this.isRunning = false;
        }
    }

    // Get clickable elements
    getClickableElements() {
        const elements = [];
        const selectors = [
            'button',
            'a[href]',
            'input[type="button"]',
            'input[type="submit"]',
            '[role="button"]',
            '[onclick]',
            '.btn',
            '.button'
        ];

        for (const selector of selectors) {
            const found = document.querySelectorAll(selector);
            elements.push(...found);
        }

        // Remove duplicates
        return [...new Set(elements)];
    }

    // Click an element
    async clickElement(element) {
        element.focus();
        await this.sleep(100);
        
        element.click();
        this.log(`Clicked: ${this.getElementDescription(element)}`, 'success');
        
        await this.sleep(100);
    }

    // Check if element is dangerous (should not be clicked in test mode)
    isDangerousElement(element) {
        const dangerousPatterns = [
            'submit', 'send', 'delete', 'remove', 'cancel', 'close',
            'logout', 'signout', 'exit', 'quit', 'buy', 'purchase',
            'pay', 'checkout', 'order', 'confirm'
        ];

        const text = (element.textContent || '').toLowerCase();
        const value = (element.value || '').toLowerCase();
        const id = (element.id || '').toLowerCase();
        const className = (element.className || '').toLowerCase();

        const combined = `${text} ${value} ${id} ${className}`;
        
        return dangerousPatterns.some(pattern => combined.includes(pattern));
    }

    // Check if element is interactable
    isElementInteractable(element) {
        if (!element || element.disabled || element.hidden) {
            return false;
        }

        const style = window.getComputedStyle(element);
        if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
            return false;
        }

        // Check if element is in viewport
        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0 && 
               rect.top >= 0 && rect.left >= 0 &&
               rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
    }

    // Get element description for logging
    getElementDescription(element) {
        const tag = element.tagName.toLowerCase();
        const id = element.id ? `#${element.id}` : '';
        const className = element.className ? `.${element.className.split(' ').join('.')}` : '';
        const text = element.textContent ? element.textContent.substring(0, 30) : '';
        
        return `${tag}${id}${className} "${text}"`.trim();
    }

    // Utility: Sleep function
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Reset auto-filler state
    reset() {
        this.isRunning = false;
        this.clearLog();
        this.log('Auto-filler reset', 'info');
    }

    // Refresh fill data from storage (called when settings are updated)
    async refreshFillData() {
        await this.loadCustomFillData();
        this.log('Fill data refreshed from settings', 'success');
    }
}

// Initialize auto-filler immediately
try {
    // Clear any previous instances
    delete window.aiExtractorAutoFiller;
    delete window.aiExtractorAutoFillerError;
    
    // Create new instance
    window.aiExtractorAutoFiller = new SmartAutoFiller();
    window.aiExtractorAutoFillerLoaded = true;
    window.aiExtractorAutoFillerInitialized = true;
    
    console.log('Element AI Extractor: Smart Auto-Filler initialized successfully');
    
} catch (error) {
    console.error('Element AI Extractor: Failed to initialize Smart Auto-Filler:', error);
    window.aiExtractorAutoFillerError = error.message;
    window.aiExtractorAutoFillerLoaded = false;
    window.aiExtractorAutoFillerInitialized = false;
}

} // End of script guard
