// Auto-Filler Module for Element AI Extractor
// Provides intelligent form filling and element interaction capabilities

// Single execution guard
if (window.aiExtractorAutoFillerScript) {
  console.log('Element AI Extractor: Auto-filler script already loaded');
} else {
  window.aiExtractorAutoFillerScript = true;

  try {
    // Define the SmartAutoFiller class
    class SmartAutoFiller {
      constructor() {
        this.isTestMode = false;
        this.fillData = this.getDefaultFillData();
        this.interactionLog = [];
        this.isRunning = false;
        this.shadowDOMSupport = true;

        // Load custom data from storage
        this.loadCustomFillData();

        // Bind methods
        this.autoFillForms = this.autoFillForms.bind(this);
        this.autoInteract = this.autoInteract.bind(this);
        this.setTestMode = this.setTestMode.bind(this);
      }

      // Load custom fill data from Chrome storage
      async loadCustomFillData() {
        try {
          if (typeof chrome !== 'undefined' && chrome.storage) {
            const result = await new Promise(resolve => {
              chrome.storage.local.get(['autoFillerCustomData'], resolve);
            });

            if (result.autoFillerCustomData) {
              // Merge custom data with defaults
              this.fillData = {...this.getDefaultFillData(), ...result.autoFillerCustomData};
              this.log('Custom fill data loaded from settings', 'info');
            }
          }
        } catch (error) {
          this.log(`Error loading custom data: ${error.message}`, 'warning');
        }
      }

      // Default data for form filling
      getDefaultFillData() {
        return {
          // Personal Information
          firstName: 'John',
          lastName: 'Doe',
          fullName: 'John Doe',
          name: 'John Doe',

          // Contact Information
          email: 'john.doe@example.com',
          phone: '+1-555-123-4567',
          mobile: '+1-555-123-4567',

          // Address Information
          address: '123 Main Street',
          street: '123 Main Street',
          city: 'New York',
          state: 'NY',
          zip: '10001',
          zipcode: '10001',
          postalCode: '10001',
          country: 'United States',

          // Company Information
          company: 'Example Corp',
          jobTitle: 'Software Engineer',
          department: 'Engineering',

          // Account Information
          username: 'johndoe123',
          password: 'TestPassword123!',

          // Other Common Fields
          age: '30',
          birthdate: '1993-01-01',
          website: 'https://example.com',
          bio: 'This is a test biography for form filling purposes.',
          message: 'This is a test message generated by the auto-filler tool.',
          comment: 'Test comment from auto-filler.',
          description: 'Test description for auto-fill demonstration.',

          // Dropdowns and Selects
          gender: 'male',
          title: 'Mr',

          // Checkboxes (boolean values)
          newsletter: true,
          terms: true,
          privacy: true,
          marketing: false
        };
      }

      // Update fill data from user settings
      updateFillData(newData) {
        this.fillData = {...this.fillData, ...newData};
        this.log('Fill data updated', 'info');
      }

      // Set test mode (safe mode - no actual form submissions)
      setTestMode(enabled) {
        this.isTestMode = enabled;
        this.log(`Test mode ${enabled ? 'enabled' : 'disabled'}`, 'info');
      }

      // Log interactions
      log(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const entry = {
          timestamp,
          message,
          type
        };
        this.interactionLog.push(entry);
        console.log(`Auto-Filler [${type.toUpperCase()}]: ${message}`);
      }

      // Clear log
      clearLog() {
        this.interactionLog = [];
      }

      // Get log entries
      getLog() {
        return this.interactionLog;
      }

      // Detect field type based on element attributes
      detectFieldType(element) {
        const name = (element.name || '').toLowerCase();
        const id = (element.id || '').toLowerCase();
        const placeholder = (element.placeholder || '').toLowerCase();
        const ariaLabel = (element.getAttribute('aria-label') || '').toLowerCase();
        const className = (element.className || '').toLowerCase();
        const type = (element.type || '').toLowerCase();

        const combined = `${name} ${id} ${placeholder} ${ariaLabel} ${className}`;

        // Email detection
        if (type === 'email' || combined.includes('email') || combined.includes('e-mail')) {
          return 'email';
        }

        // Password detection
        if (type === 'password' || combined.includes('password') || combined.includes('pass')) {
          return 'password';
        }

        // Phone detection
        if (type === 'tel' || combined.includes('phone') || combined.includes('tel') || combined.includes('mobile') || combined.includes('cell')) {
          return 'phone';
        }

        // Name detection
        if (combined.includes('firstname') || combined.includes('first-name') || combined.includes('first_name')) {
          return 'firstName';
        }
        if (combined.includes('lastname') || combined.includes('last-name') || combined.includes('last_name')) {
          return 'lastName';
        }
        if (combined.includes('fullname') || combined.includes('full-name') || combined.includes('full_name') || (combined.includes('name') && !combined.includes('user') && !combined.includes('company'))) {
          return 'fullName';
        }
        if (combined.includes('username') || combined.includes('user-name') || combined.includes('user_name')) {
          return 'username';
        }

        // Address detection
        if (combined.includes('address') || combined.includes('street')) {
          return 'address';
        }
        if (combined.includes('city')) {
          return 'city';
        }
        if (combined.includes('state') || combined.includes('province')) {
          return 'state';
        }
        if (combined.includes('zip') || combined.includes('postal')) {
          return 'zip';
        }
        if (combined.includes('country')) {
          return 'country';
        }

        // Company detection
        if (combined.includes('company') || combined.includes('organization')) {
          return 'company';
        }
        if (combined.includes('job') && combined.includes('title')) {
          return 'jobTitle';
        }

        // Other common fields
        if (combined.includes('age')) {
          return 'age';
        }
        if (combined.includes('birth') || combined.includes('dob')) {
          return 'birthdate';
        }
        if (combined.includes('website') || combined.includes('url')) {
          return 'website';
        }
        if (combined.includes('bio') || combined.includes('about')) {
          return 'bio';
        }
        if (combined.includes('message') || combined.includes('msg')) {
          return 'message';
        }
        if (combined.includes('comment')) {
          return 'comment';
        }
        if (combined.includes('description') || combined.includes('desc')) {
          return 'description';
        }

        // Generic text fallback
        if (type === 'text' || type === 'search' || element.tagName === 'TEXTAREA') {
          return 'fullName'; // Default text input
        }

        return null;
      }

      // Fill a single form element
      async fillElement(element, fieldType, value) {
        if (!element || element.disabled || element.readOnly) {
          return false;
        }

        try {
          // Focus the element first
          element.focus();
          await this.sleep(100);

          if (element.tagName === 'SELECT') {
            // Handle dropdowns
            return this.fillSelect(element, value);
          } else if (element.type === 'checkbox' || element.type === 'radio') {
            // Handle checkboxes and radio buttons
            return this.fillCheckboxRadio(element, value);
          } else if (element.tagName === 'TEXTAREA' || element.type === 'text' || element.type === 'email' || element.type === 'tel' || element.type === 'password' || element.type === 'search' || element.type === 'url') {
            // Handle text inputs
            return this.fillTextInput(element, value);
          }

          return false;
        } catch (error) {
          this.log(`Error filling element: ${error.message}`, 'error');
          return false;
        }
      }

      // Fill text input
      async fillTextInput(element, value) {
        try {
          // Clear existing value
          element.value = '';
          element.dispatchEvent(new Event('input', {bubbles: true}));
          await this.sleep(50);

          // Type the new value
          element.value = value;

          // Dispatch events to trigger any listeners
          element.dispatchEvent(new Event('input', {bubbles: true}));
          element.dispatchEvent(new Event('change', {bubbles: true}));
          element.dispatchEvent(new Event('blur', {bubbles: true}));

          await this.sleep(100);
          this.log(`Filled text input with: ${value}`, 'success');
          return true;
        } catch (error) {
          this.log(`Error filling text input: ${error.message}`, 'error');
          return false;
        }
      }

      // Fill select dropdown
      async fillSelect(element, value) {
        try {
          // Try to find matching option by value or text
          const options = Array.from(element.options);
          let selectedOption = null;

          // First try exact value match
          selectedOption = options.find(opt => opt.value.toLowerCase() === value.toLowerCase());

          // Then try text content match
          if (!selectedOption) {
            selectedOption = options.find(opt => opt.textContent.toLowerCase().includes(value.toLowerCase()));
          }

          // Finally try any option that isn't empty/default
          if (!selectedOption) {
            selectedOption = options.find(opt => opt.value && opt.value !== '0' && opt.textContent.trim());
          }

          if (selectedOption) {
            element.value = selectedOption.value;
            element.selectedIndex = selectedOption.index;
            element.dispatchEvent(new Event('change', {bubbles: true}));
            await this.sleep(100);
            this.log(`Selected option: ${selectedOption.textContent}`, 'success');
            return true;
          }

          this.log(`No suitable option found for value: ${value}`, 'warning');
          return false;
        } catch (error) {
          this.log(`Error filling select: ${error.message}`, 'error');
          return false;
        }
      }

      // Fill checkbox or radio button
      async fillCheckboxRadio(element, value) {
        try {
          const shouldCheck = Boolean(value);
          if (element.checked !== shouldCheck) {
            element.checked = shouldCheck;
            element.dispatchEvent(new Event('change', {bubbles: true}));
            await this.sleep(100);
            this.log(`${shouldCheck ? 'Checked' : 'Unchecked'} ${element.type}: ${element.name || element.id}`, 'success');
            return true;
          }
          return false;
        } catch (error) {
          this.log(`Error filling ${element.type}: ${error.message}`, 'error');
          return false;
        }
      }

      // Get all form elements from the page (including shadow DOM)
      getAllFormElements() {
        const elements = [];

        // Regular DOM elements
        const regularElements = document.querySelectorAll('input, select, textarea');
        elements.push(...regularElements);

        // Shadow DOM elements if supported
        if (this.shadowDOMSupport) {
          try {
            const shadowElements = this.getShadowDOMElements();
            elements.push(...shadowElements);
          } catch (error) {
            this.log(`Error accessing shadow DOM: ${error.message}`, 'warning');
          }
        }

        return elements;
      }

      // Get form elements from shadow DOM
      getShadowDOMElements() {
        const elements = [];

        const getAllShadowRoots = root => {
          const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null, false);

          let node;
          while ((node = walker.nextNode())) {
            if (node.shadowRoot) {
              const shadowElements = node.shadowRoot.querySelectorAll('input, select, textarea');
              elements.push(...shadowElements);
              // Recursively check nested shadow roots
              getAllShadowRoots(node.shadowRoot);
            }
          }
        };

        getAllShadowRoots(document);
        return elements;
      }

      // Main auto-fill function
      async autoFillForms() {
        if (this.isRunning) {
          this.log('Auto-fill already in progress', 'warning');
          return;
        }

        this.isRunning = true;
        this.clearLog();
        this.log('Starting auto-fill process...', 'info');

        try {
          const elements = this.getAllFormElements();
          this.log(`Found ${elements.length} form elements`, 'info');

          let filledCount = 0;
          let skippedCount = 0;

          for (const element of elements) {
            // Skip if element is not visible or interactable
            if (!this.isElementInteractable(element)) {
              skippedCount++;
              continue;
            }

            const fieldType = this.detectFieldType(element);
            if (fieldType && this.fillData[fieldType]) {
              const success = await this.fillElement(element, fieldType, this.fillData[fieldType]);
              if (success) {
                filledCount++;
              } else {
                skippedCount++;
              }
            } else {
              skippedCount++;
            }

            // Small delay between fills
            await this.sleep(200);
          }

          this.log(`Auto-fill completed: ${filledCount} filled, ${skippedCount} skipped`, 'success');
        } catch (error) {
          this.log(`Auto-fill error: ${error.message}`, 'error');
          throw error;
        } finally {
          this.isRunning = false;
        }
      }

      // Auto-interact with clickable elements
      async autoInteract() {
        if (this.isRunning) {
          this.log('Auto-interact already in progress', 'warning');
          return;
        }

        this.isRunning = true;
        this.log('Starting auto-interact process...', 'info');

        try {
          const clickableElements = this.getClickableElements();
          this.log(`Found ${clickableElements.length} clickable elements`, 'info');

          let interactCount = 0;
          let skippedCount = 0;

          for (const element of clickableElements) {
            // Skip dangerous elements in test mode
            if (this.isTestMode && this.isDangerousElement(element)) {
              this.log(`Skipped dangerous element in test mode: ${this.getElementDescription(element)}`, 'warning');
              skippedCount++;
              continue;
            }

            // Skip if element is not visible or interactable
            if (!this.isElementInteractable(element)) {
              skippedCount++;
              continue;
            }

            try {
              await this.clickElement(element);
              interactCount++;
              await this.sleep(500); // Longer delay between clicks
            } catch (error) {
              this.log(`Failed to click element: ${error.message}`, 'error');
              skippedCount++;
            }
          }

          this.log(`Auto-interact completed: ${interactCount} clicked, ${skippedCount} skipped`, 'success');
        } catch (error) {
          this.log(`Auto-interact error: ${error.message}`, 'error');
          throw error;
        } finally {
          this.isRunning = false;
        }
      }

      // Get clickable elements
      getClickableElements() {
        const elements = [];
        const selectors = ['button', 'a[href]', 'input[type="button"]', 'input[type="submit"]', '[role="button"]', '[onclick]', '.btn', '.button'];

        for (const selector of selectors) {
          const found = document.querySelectorAll(selector);
          elements.push(...found);
        }

        // Remove duplicates
        return [...new Set(elements)];
      }

      // Click an element
      async clickElement(element) {
        element.focus();
        await this.sleep(100);

        element.click();
        this.log(`Clicked: ${this.getElementDescription(element)}`, 'success');

        await this.sleep(100);
      }

      // Check if element is dangerous (should not be clicked in test mode)
      isDangerousElement(element) {
        const dangerousPatterns = ['submit', 'send', 'delete', 'remove', 'cancel', 'close', 'logout', 'signout', 'exit', 'quit', 'buy', 'purchase', 'pay', 'checkout', 'order', 'confirm'];

        const text = (element.textContent || '').toLowerCase();
        const value = (element.value || '').toLowerCase();
        const id = (element.id || '').toLowerCase();
        const className = (element.className || '').toLowerCase();

        const combined = `${text} ${value} ${id} ${className}`;

        return dangerousPatterns.some(pattern => combined.includes(pattern));
      }

      // Check if element is interactable
      isElementInteractable(element) {
        if (!element || element.disabled || element.hidden) {
          return false;
        }

        const style = window.getComputedStyle(element);
        if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') {
          return false;
        }

        // Check if element is in viewport
        const rect = element.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0 && rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth;
      }

      // Get element description for logging
      getElementDescription(element) {
        const tag = element.tagName.toLowerCase();
        const id = element.id ? `#${element.id}` : '';
        const className = element.className ? `.${element.className.split(' ').join('.')}` : '';
        const text = element.textContent ? element.textContent.substring(0, 30) : '';

        return `${tag}${id}${className} "${text}"`.trim();
      }

      // Utility: Sleep function
      sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // Reset auto-filler state
      reset() {
        this.isRunning = false;
        this.clearLog();
        this.log('Auto-filler reset', 'info');
      }

      // Refresh fill data from storage (called when settings are updated)
      async refreshFillData() {
        await this.loadCustomFillData();
        this.log('Fill data refreshed from settings', 'success');
      }
    }

    // Initialize auto-filler immediately
    try {
      // Clear any previous instances
      delete window.aiExtractorAutoFiller;
      delete window.aiExtractorAutoFillerError;

      // Create new instance
      window.aiExtractorAutoFiller = new SmartAutoFiller();
      window.aiExtractorAutoFillerLoaded = true;
      window.aiExtractorAutoFillerInitialized = true;

      console.log('Element AI Extractor: Smart Auto-Filler initialized successfully');
    } catch (error) {
      console.error('Element AI Extractor: Failed to initialize Smart Auto-Filler:', error);
      window.aiExtractorAutoFillerError = error.message;
      window.aiExtractorAutoFillerLoaded = false;
      window.aiExtractorAutoFillerInitialized = false;
    }
  } catch (error) {
    console.error('Element AI Extractor: Error in auto-filler script:', error);
  }
} // End of script guard
