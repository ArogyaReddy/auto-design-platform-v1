/**
 * Elements Extractor Integration with Automation Locator Tester
 * Add this to your Elements Extractor to automatically validate generated locators
 */

// Integration function to validate locators generated by Elements Extractor
function validateElementsExtractorLocator(locator, element = null) {
    if (typeof testLocator === 'undefined') {
        console.error('⚠️ Automation Locator Tester not loaded. Please load automation-locator-tester.js first.');
        return null;
    }
    
    console.log(`🔍 Validating Elements Extractor locator: ${locator}`);
    
    const result = testLocator(locator, false);
    
    // Enhanced analysis for Elements Extractor context
    const analysis = {
        original: locator,
        rating: result.overall,
        isDevToolsCompatible: result.tests.browser.supported && result.tests.browser.valid,
        automationScores: {
            playwright: result.tests.playwright.score,
            selenium: result.tests.selenium.score,
            cypress: result.tests.cypress.score
        },
        elementCount: result.elements.length,
        recommendations: result.recommendations,
        alternatives: []
    };
    
    // Generate alternatives if the original locator is problematic
    if (result.overall === 'POOR' || result.overall === 'FAIR') {
        console.log('⚠️ Generated locator has compatibility issues. Finding alternatives...');
        
        try {
            const elements = document.querySelectorAll(locator);
            if (elements.length > 0) {
                const tester = new AutomationLocatorTester();
                const alternatives = tester.generateAlternatives(elements[0]);
                
                // Test each alternative and rank them
                const rankedAlternatives = alternatives
                    .map(alt => {
                        const altResult = testLocator(alt, false);
                        return {
                            locator: alt,
                            rating: altResult.overall,
                            playwrightScore: altResult.tests.playwright.score,
                            devToolsCompatible: altResult.tests.browser.supported && altResult.tests.browser.valid,
                            elementCount: altResult.elements.length
                        };
                    })
                    .filter(alt => alt.elementCount === 1) // Prefer unique selectors
                    .sort((a, b) => b.playwrightScore - a.playwrightScore);
                
                analysis.alternatives = rankedAlternatives;
                
                if (rankedAlternatives.length > 0) {
                    console.log('💡 Better alternatives found:');
                    rankedAlternatives.slice(0, 3).forEach((alt, index) => {
                        console.log(`   ${index + 1}. ${alt.locator} (${alt.rating}, ${alt.playwrightScore}% Playwright)`);
                    });
                }
            }
        } catch (error) {
            console.warn('Error generating alternatives:', error);
        }
    } else {
        console.log(`✅ Locator is ${result.overall} - good for automation!`);
    }
    
    return analysis;
}

// Enhanced getBestLocator function that integrates validation
function getBestLocatorWithValidation(el, contextNode = document) {
    // Get the original best locator from Elements Extractor
    const originalResult = getBestLocator(el, contextNode);
    
    // Validate it with our automation tester
    const validation = validateElementsExtractorLocator(originalResult.locator, el);
    
    if (validation && validation.alternatives.length > 0 && validation.rating === 'POOR') {
        const bestAlternative = validation.alternatives[0];
        
        console.log(`🔄 Switching from "${originalResult.locator}" to "${bestAlternative.locator}" for better compatibility`);
        
        return {
            type: 'validated-' + originalResult.type,
            locator: bestAlternative.locator,
            reason: `Validated: ${bestAlternative.rating} (${bestAlternative.playwrightScore}% Playwright) - Original: ${validation.rating}`,
            originalLocator: originalResult.locator,
            validationScore: bestAlternative.playwrightScore
        };
    }
    
    // Return original if it's already good or no alternatives found
    return {
        ...originalResult,
        validationScore: validation ? validation.automationScores.playwright : 0,
        devToolsCompatible: validation ? validation.isDevToolsCompatible : false
    };
}

// Batch validation function for testing multiple locators from Elements Extractor
function validateAllExtractedLocators(extractedData) {
    console.log('🧪 Validating all Elements Extractor locators...');
    
    const validationResults = extractedData.map(item => {
        const validation = validateElementsExtractorLocator(item['Best Locator']);
        return {
            elementName: item['Element Name'],
            originalLocator: item['Best Locator'],
            validation: validation,
            needsImprovement: validation && (validation.rating === 'POOR' || validation.rating === 'FAIR')
        };
    });
    
    const summary = {
        total: validationResults.length,
        excellent: validationResults.filter(r => r.validation?.rating === 'EXCELLENT').length,
        good: validationResults.filter(r => r.validation?.rating === 'GOOD').length,
        fair: validationResults.filter(r => r.validation?.rating === 'FAIR').length,
        poor: validationResults.filter(r => r.validation?.rating === 'POOR').length,
        problematic: validationResults.filter(r => r.needsImprovement)
    };
    
    console.log('📊 Validation Summary:');
    console.log(`   Total: ${summary.total}`);
    console.log(`   Excellent: ${summary.excellent} (${Math.round(summary.excellent/summary.total*100)}%)`);
    console.log(`   Good: ${summary.good} (${Math.round(summary.good/summary.total*100)}%)`);
    console.log(`   Fair: ${summary.fair} (${Math.round(summary.fair/summary.total*100)}%)`);
    console.log(`   Poor: ${summary.poor} (${Math.round(summary.poor/summary.total*100)}%)`);
    
    if (summary.problematic.length > 0) {
        console.log('\n⚠️ Elements needing better locators:');
        summary.problematic.forEach(item => {
            console.log(`   "${item.elementName}": ${item.originalLocator} (${item.validation.rating})`);
            if (item.validation.alternatives.length > 0) {
                console.log(`      → Suggested: ${item.validation.alternatives[0].locator}`);
            }
        });
    }
    
    return {
        results: validationResults,
        summary: summary
    };
}

// Auto-enhance function to automatically improve problematic locators
function autoEnhanceLocators(extractedData) {
    console.log('🚀 Auto-enhancing problematic locators...');
    
    return extractedData.map(item => {
        const validation = validateElementsExtractorLocator(item['Best Locator']);
        
        if (validation && validation.rating === 'POOR' && validation.alternatives.length > 0) {
            const bestAlt = validation.alternatives[0];
            
            return {
                ...item,
                'Best Locator': bestAlt.locator,
                'Locator Type': 'auto-enhanced',
                'Strength': Math.min(95, bestAlt.playwrightScore),
                'Original Locator': item['Best Locator'],
                'Enhancement Reason': `Auto-enhanced from ${validation.rating} to ${bestAlt.rating}`
            };
        }
        
        return item;
    });
}

// Console commands for easy testing
window.validateLocator = validateElementsExtractorLocator;
window.enhanceLocators = autoEnhanceLocators;
window.validateAllLocators = validateAllExtractedLocators;

console.log('✅ Elements Extractor + Automation Locator Tester integration loaded!');
console.log('Usage:');
console.log('  validateLocator("path:nth-of-type(2)")');
console.log('  validateAllLocators(extractedElements)');
console.log('  enhanceLocators(extractedElements)');
